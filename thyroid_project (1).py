# -*- coding: utf-8 -*-
"""Thyroid_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1foEGRe79xTjB_J2JMDHZOXouydAL_b-I
"""

#Importing pandas library
import pandas as pd

#Reading the csv dataset file
thyroid = pd.read_csv("thyroid_dataset.csv")

thyroid

#Dropping unnecessary columns
thyroid = thyroid.drop("query_on_thyroxine",axis=1)

#Dropping unnecessary columns
thyroid = thyroid.drop(["sick","query_hypothyroid"],axis=1)

#Dropping unnecessary columns
thyroid = thyroid.drop(["query_hyperthyroid", "tumor","hypopituitary","psych","referral_source"],axis=1)

thyroid.head(40)

#Checking how many null values are present in a column
thyroid.isnull().sum()

#Dropping unnecessary columns
thyroid = thyroid.drop(["T3_measured", "T3","TBG_measured","TBG"],axis=1)

#Checking for number of unique values in a column
thyroid.nunique()

#Checking for number of unique values in a individual column
target = thyroid["target"].value_counts()
print(target)

thyroid = thyroid[thyroid["target"] != "E"]

#Deleting unnecessary values or values who are not in larger quantity in dataset
values_to_delete = ["D|R","OI","GKJ","LJ","MI","P","FK","C","D"]

#Delete rows
thyroid = thyroid[~thyroid['target'].isin(values_to_delete)]

thyroid.describe()

thyroid.isnull().sum()

#Dropping rows with null values
thyroid.dropna(subset=["sex"],inplace=True)

#TSH - 0.4-4.0 milliunits per litre
#TT4 - 58-161 nanomoles per liter
#T4U =

"""# TSH"""

#importing matplotlib library
import matplotlib.pyplot as plt

#Checking for number of unique values in a individual column
TSH = thyroid["TSH"].value_counts().sum()
print(TSH)

import seaborn as sns
import matplotlib.pyplot as plt


# Create a box plot using seaborn
sns.boxplot(y='TSH', data=thyroid)

# Show the plot
plt.title('Box Plot of TSH')
plt.show()

import numpy as np

# Creating random values between 19 and 60. total 100 value
ages = np.random.normal(loc=39.5, scale=7, size=100) # here mean is 39.5 and std dev is 7

plt.hist(ages)
plt.show()

#plotting scatterplot using matplotlib
plt.scatter(range(len(thyroid['TSH'])), thyroid['TSH'])

sns.boxplot(thyroid["TSH"])

# Set the threshold value
threshold_value = 20

# Count the occurrences of values greater than or equal to the threshold
filtered_counts = thyroid[thyroid['TSH'] >= threshold_value]['TSH'].value_counts().sum()

# Display the counts
print(filtered_counts)

#Dropping rows which has value over the given threshold
thyroid.drop(thyroid[thyroid['TSH'] > 20].index, inplace=True)

# Set the desired range for the boxplot
desired_range = (0,20)

# Filter the data within the specified range
filtered_data = (thyroid["TSH"])[((thyroid["TSH"]) >= desired_range[0]) & ( (thyroid["TSH"]) <= desired_range[1])]

# Create a boxplot with the filtered data
plt.boxplot(filtered_data, vert=True)
plt.title('Boxplot with a Specific Range')
plt.xlabel('Values')
plt.show()



#Finding IQR
Percentile_TSH_25 = thyroid["TSH"].quantile(0.25)
Percentile_TSH_75 = thyroid["TSH"].quantile(0.75)
print(Percentile_TSH_25,Percentile_TSH_75)

IQR_TSH = Percentile_TSH_75 - Percentile_TSH_25
print(IQR_TSH)

upper_limit_TSH = Percentile_TSH_75 + 1.5*IQR_TSH
lower_limit_TSH = Percentile_TSH_25 - 1.5*IQR_TSH

print("upper limit",upper_limit_TSH)
print("lower limit", lower_limit_TSH)

#calculating the skewness
thyroid["TSH"].skew()

#Replacing null values with median (median as data is skewed)
median_value_TSH = thyroid["TSH"].median()
thyroid["TSH"].fillna(median_value_TSH,inplace = True)

thyroid.isnull().sum()

"""## TT4"""



# Set the threshold value
threshold_value = 185

# Count the occurrences of values greater than or equal to the threshold
filtered_counts = thyroid[thyroid['TT4'] >= threshold_value]['TT4'].value_counts().sum()

# Display the counts
print(filtered_counts)

# Set the desired range for the boxplot
desired_range = (0,161)

# Filter the data within the specified range
filtered_data = (thyroid["TT4"])[((thyroid["TT4"]) >= desired_range[0]) & ( (thyroid["TT4"]) <= desired_range[1])]

# Create a boxplot with the filtered data
plt.boxplot(filtered_data, vert=True)
plt.title('Boxplot with a Specific Range')
plt.xlabel('Values')
plt.show()

sns.boxplot(thyroid["TT4"])

#checking the skewness of the data
thyroid["TT4"].skew()

# import numpy as np
# import matplotlib.pyplot as plt


# # Plot the original skewed data
# plt.figure(figsize=(10, 6))
# plt.subplot(1, 2, 1)
# plt.hist(thyroid, bins=30, edgecolor='black')
# plt.title('Skewed Data')


# # Apply log transformation
# thyroid = np.log1p(thyroid.TSH)

# # Plot the log-transformed data
# plt.subplot(1, 2, 2)
# plt.hist(thyroid, bins=30, edgecolor='black')
# plt.title('Log-Transformed Data')

# plt.show()

#finding IQR
Percentile_25_TT4 = thyroid["TT4"].quantile(0.25)
Percentile_75_TT4 = thyroid["TT4"].quantile(0.75)
print(Percentile_25_TT4,Percentile_75_TT4)

IQR_TT4 = Percentile_75_TT4 - Percentile_25_TT4
print(IQR_TT4)

#Calculating UL and LL
upper_limit_TT4 = Percentile_75_TT4 + 1.5*IQR_TT4
lower_limit_TT4 = Percentile_25_TT4 - 1.5*IQR_TT4

print("upper limit",upper_limit_TT4)
print("lower limit", lower_limit_TT4)

#Replacing null values with median (median as data is skewed)
median_value_TT4 = thyroid["TT4"].median()
thyroid["TT4"].fillna(median_value_TT4,inplace = True)

thyroid.isnull().sum()

"""# T4U"""

thyroid.isnull().sum()

sns.boxplot(thyroid["T4U"])

# Set the threshold value
threshold_value = 1.3

# Count the occurrences of values greater than or equal to the threshold
filtered_counts = thyroid[thyroid['T4U'] >= threshold_value]['T4U'].value_counts().sum()

# Display the counts
print(filtered_counts)

#checking the skewness of the data
thyroid["T4U"].skew()

Percentile_25_T4U = thyroid["T4U"].quantile(0.25)
Percentile_75_T4U = thyroid["T4U"].quantile(0.75)
print(Percentile_25_T4U,Percentile_75_T4U)

IQR_T4U = Percentile_75_T4U - Percentile_25_T4U
print(IQR_T4U)

upper_limit_T4U = Percentile_75_T4U + 1.5*IQR_T4U
lower_limit_T4U = Percentile_25_T4U - 1.5*IQR_T4U

print("upper limit",upper_limit_T4U)
print("lower limit", lower_limit_T4U)

#Replacing null values with median (median as data is skewed)
median_value_T4U = thyroid["T4U"].median()
thyroid["T4U"].fillna(median_value_T4U,inplace = True)

thyroid.isnull().sum()

"""# FTI"""

sns.boxplot(thyroid["FTI"])

# Set the threshold value
threshold_value = 190

# Count the occurrences of values greater than or equal to the threshold
filtered_counts = thyroid[thyroid['FTI'] >= threshold_value]['FTI'].value_counts().sum()

# Display the counts
print(filtered_counts)

#checking the skewness of the data (positive value indicates right skewed data)
thyroid["FTI"].skew()

plt.hist(thyroid["FTI"])

Percentile_25_FTI = thyroid["FTI"].quantile(0.25)
Percentile_75_FTI = thyroid["FTI"].quantile(0.75)
print(Percentile_25_FTI,Percentile_75_FTI)

IQR_FTI = Percentile_75_FTI - Percentile_25_FTI
print(IQR_FTI)

upper_limit_FTI = Percentile_75_FTI + 1.5*IQR_FTI
lower_limit_FTI = Percentile_25_FTI - 1.5*IQR_FTI

print("upper limit",upper_limit_FTI)
print("lower limit", lower_limit_FTI)

#Replacing null values with median (median as data is skewed)
median_value_FTI = thyroid["FTI"].median()
thyroid["FTI"].fillna(median_value_FTI,inplace = True)

thyroid.isnull().sum()

"""## Finding Outliers"""

thyroid.nunique()

import pandas as pd

# Assuming 'df' is your DataFrame and 'column_name' is the column you want to sort by
# Replace 'column_name' with the actual column name you are interested in

# Sort the DataFrame by the specified column in ascending order
sorted_df = thyroid.sort_values(by='TSH')

# Display the sorted DataFrame
print(sorted_df)

thyroid["target"]= thyroid["target"].replace("-",0)

"""# Encoding"""

#one hot encoding of gender column
thyroid = pd.get_dummies(thyroid,columns = ["sex"],prefix = "sex")

#label_encoding
from sklearn.preprocessing import LabelEncoder
label_encoder = LabelEncoder()
columns_to_encode = ["TSH_measured","TT4_measured","T4U_measured","FTI_measured"]
for column in columns_to_encode:
    thyroid[column]= label_encoder.fit_transform(thyroid[column])

#Label Encoding
columns_to_encode_1 = ["on_thyroxine","on_antithyroid_meds","pregnant","thyroid_surgery","I131_treatment","lithium" ,"goitre"  ]
for column in columns_to_encode_1:
    thyroid[column]= label_encoder.fit_transform(thyroid[column])

# Check if the 'target' column has non-numeric values
# if thyroid['target'].dtype == 'object':
#     # Label encode non-numeric values, leaving 0 unchanged
#     thyroid['target'] = thyroid['target'].apply(lambda x: label_encoder.fit_transform([x])[0] if x != 0 else 0)

thyroid['target'] = thyroid['target'].astype(str)
thyroid['target'] = label_encoder.fit_transform(thyroid['target'])

print("Encoded labels:", thyroid['encoded_target'].unique())

"""# Prediction models"""

#splitting the data
from sklearn.model_selection import train_test_split

X = thyroid.drop('target', axis=1)  # Features
y = thyroid['target']                # Labels

# # Step 1: Split into training and temporary (test + validation) sets
X_train,X_temp,y_train,y_temp = train_test_split(X,y,test_size=0.3,random_state=42)

# Step 2: Split the temporary set into test and validation sets
X_test,X_val,y_test,y_val = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42)

# Print the sizes of the sets
print("Training set size:", len(X_train))
print("Test set size:", len(X_test))
print("Validation set size:", len(X_val))

"""## Logistic Regression"""

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report
# Create a logistic regression model
model = LogisticRegression()

# Train the model on the training set
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_val)

# Evaluate the model
accuracy = accuracy_score(y_val, y_pred)
report = classification_report(y_val, y_pred)

# Print the results
print(f"Accuracy: {accuracy:.2f}")
print("Classification Report:\n", report)

"""## Decision Tree"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, classification_report
# Create a decision tree model
model = DecisionTreeClassifier(random_state=42)

# Train the model on the training set
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)

# Print the results
print(f"Accuracy: {accuracy:.2f}")
print("Classification Report:\n", report)

"""## Random Forest  """

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
# Create a Random Forest model
rf_model = RandomForestClassifier(n_estimators=100, random_state=42)

# Train the model on the training set
rf_model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = rf_model.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)

# Print the results
print(f"Accuracy: {accuracy:.2f}")
print("Classification Report:\n", report)

"""## KNN"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, classification_report

# Create a KNN model with k=3 (you can adjust the 'n_neighbors' parameter)
knn_model = KNeighborsClassifier(n_neighbors=3)

# Train the model on the training set
knn_model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = knn_model.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)

# Print the results
print(f"Accuracy: {accuracy:.2f}")
print("Classification Report:\n", report)

# Import necessary libraries
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, classification_report


# Create an SVM model with a radial basis function (RBF) kernel
svm_model = SVC(kernel='rbf', C=1.0, gamma='scale')

# Train the model on the training set
svm_model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = svm_model.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)

# Print the results
print(f"Accuracy: {accuracy:.2f}")
print("Classification Report:\n", report)

"""## Data visualization"""

from matplotlib import pyplot as plt
# Increase the size of the heatmap.
plt.figure(figsize=(16, 6))
heatmap = sns.heatmap(thyroid.corr(), vmin=-1, vmax=1, annot=True)
# Give a title to the heatmap. Pad defines the distance of the title from the top of the heatmap.
heatmap.set_title('Correlation Heatmap', fontdict={'fontsize':12}, pad=12);

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics.pairwise import pairwise_distances
from sklearn.manifold import MDS
import pandas as pd

# Assuming 'thyroid' is your dataset and 'target' is the dependent variable
# Replace 'your_dataset' and 'your_target' with your actual dataset and target variable

# Example data loading (replace this with your actual data loading)

X = thyroid.drop('target', axis=1)  # Assuming 'target' is the dependent variable

# Create a distance matrix (replace 'euclidean' with the appropriate distance metric)
distance_matrix = pairwise_distances(X, metric='euclidean')

# Perform PCoA using MDS
mds = MDS(n_components=2, dissimilarity='precomputed')
X_pcoa = mds.fit_transform(distance_matrix)

# Plot PCoA
plt.figure(figsize=(8, 6))
plt.scatter(X_pcoa[:, 0], X_pcoa[:, 1], c=thyroid['target'], cmap='viridis', edgecolor='k', s=50)
plt.title('PCoA of Thyroid Dataset')
plt.xlabel('Principal Coordinate 1')
plt.ylabel('Principal Coordinate 2')
plt.colorbar(label='Target Class')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import learning_curve
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
import pandas as pd

# Assuming 'thyroid' is your dataset and 'target' is the dependent variable
# Replace 'your_dataset' and 'your_target' with your actual dataset and target variable

# Example data loading (replace this with your actual data loading)
X = thyroid.drop('target', axis=1)  # Assuming 'target' is the dependent variable
y = thyroid['target']

# Split the data into training and validation sets
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a Decision Tree classifier (replace this with your own model)
clf = DecisionTreeClassifier()

# Learning curve analysis
train_sizes, train_scores, val_scores = learning_curve(
    clf, X_train, y_train, train_sizes=np.linspace(0.1, 1.0, 10), cv=5, scoring='accuracy'
)

# Calculate mean and standard deviation of scores
train_scores_mean = np.mean(train_scores, axis=1)
train_scores_std = np.std(train_scores, axis=1)
val_scores_mean = np.mean(val_scores, axis=1)
val_scores_std = np.std(val_scores, axis=1)

# Plot learning curves
plt.figure(figsize=(10, 6))
plt.title('Learning Curve - Decision Tree Classifier')
plt.xlabel('Training Examples')
plt.ylabel('Accuracy')
plt.grid(True)

plt.fill_between(train_sizes, train_scores_mean - train_scores_std,
                 train_scores_mean + train_scores_std, alpha=0.1, color='blue')
plt.fill_between(train_sizes, val_scores_mean - val_scores_std,
                 val_scores_mean + val_scores_std, alpha=0.1, color='orange')

plt.plot(train_sizes, train_scores_mean, 'o-', color='blue', label='Training Accuracy')
plt.plot(train_sizes, val_scores_mean, 'o-', color='orange', label='Validation Accuracy')

plt.legend(loc='best')
plt.show()

from sklearn.ensemble import RandomForestClassifier

# Create a Random Forest model
random_forest = RandomForestClassifier(n_estimators=100, random_state=42)

# Train the model on the training set
random_forest.fit(X_train, y_train)

#exporting the model using pickle
import pickle
pickle.dump(random_forest,open("model.pkl","wb"))